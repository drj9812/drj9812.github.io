---
title: JVM
categories: [공부, JVM]
tags: [JVM, stack, 스택, heap, 힙, GC, Garbage Collection, 가비지 컬렉션, Garbage Collector, 가비지 컬렉터, 메모리, 메모리 구조]
---

# JVM

![01-internal-architecture-of-jvm](/assets/img/posts/study/java/jvm/01-internal-architecture-of-jvm.gif)*출처 - [https://www.artima.com/insidejvm/ed2/jvm2.html](https://www.artima.com/insidejvm/ed2/jvm2.html){: target="_blank" }*

## The Class Loader Subsystem

## Runtime Data Areas

- JVM이 프로그램을 실행할 때 로드된 클래스 파일에서 추출한 정보들을 저장하는 영역
- 모든 JVM에는 이 영역이 어떤 형태로든 존재하지만 매우 추상적이며, 구조적 세부 사항에 대한 결정은 설계자에게 달려있음

### Method Area(Class Area)

- 모든 스레드에서 공유됨

#### Type Information

- `java.lang.object`와 같은 타입의 완전한 이름
	+ 클래스 파일에서 점(.)은 슬래시(/)로 대체됨
- 타입의 superclass의 완전한 이름
	+ 타입이 인터페이스 또는 `java.lang.object`인 경우 제외
- 타입이 클래스인지 인터페이스인지 여부
- 타입의 접근 제어자
- 모든 superinterface의 완전한 이름이 순서대로 나열된 목록

#### The Constant Pool

- 리터럴(문자열, 정수 및 부동 소수점)
- 타입, 필드 및 메소드에 대한 symbolic reference
- `final`로 선언된 클래스 변수

> 상수 풀에 저장된 값들은 JVM에 의해 자동으로 메모리에서 관리되며, GC(Garbage Collector)의 대상이 되지 않음
{: .prompt-info }

#### Field Information

- 클래스나 인터페이스에서 필드를 선언한 순서
- 필드(멤버 변수, 전역 변수)의 이름
- 필드의 타입
- 필드의 접근 제어자

#### Method Information

- 클래스나 인터페이스에서 메서드를 선언한 순서
- 메서드의 이름
- 리턴 타입
- 파라미터의 개수 및 타입(순서대로)
- 메서드의 접근 제어자

#### Class Variables(Static Variables)

- `final`로 선언되지 않은 클래스 변수

#### A reference to class `ClassLoader`

For each type it loads, a Java virtual machine must keep track of whether or not the type was loaded via the bootstrap class loader or a user-defined class loader. For those types loaded via a user-defined class loader, the virtual machine must store a reference to the user-defined class loader that loaded the type. This information is stored as part of the type's data in the method area.

The virtual machine uses this information during dynamic linking. When one type refers to another type, the virtual machine requests the referenced type from the same class loader that loaded the referencing type. This process of dynamic linking is also central to the way the virtual machine forms separate name spaces. To be able to properly perform dynamic linking and maintain multiple name spaces, the virtual machine needs to know what class loader loaded each type in its method area. The details of dynamic linking and name spaces are given in Chapter 8, "The Linking Model."

#### A reference to class `Class`

An instance of class `java.lang.Class` is created by the Java virtual machine for every type it loads. The virtual machine must in some way associate a reference to the `Class` instance for a type with the type's data in the method area.

Your Java programs can obtain and use references to `Class` objects. One static method in class `Class`, allows you to get a reference to the `Class` instance for any loaded class:

```java
// A method declared in class java.lang.Class:
public static Class forName(String className);
```

If you invoke `forName("java.lang.Object")`, for example, you will get a reference to the `Class` object that represents `java.lang.Object`. If you invoke `forName("java.util.Enumeration")`, you will get a reference to the `Class` object that represents the `Enumeration` interface from the `java.util` package. You can use `forName()` to get a `Class` reference for any loaded type from any package, so long as the type can be (or already has been) loaded into the current name space. If the virtual machine is unable to load the requested type into the current name space, `forName()` will throw `ClassNotFoundException`.

An alternative way to get a Class reference is to invoke `getClass()` on any object reference. This method is inherited by every object from class `Object` itself:

```java
// A method declared in class java.lang.Object:
public final Class getClass();
```

If you have a reference to an object of class `java.lang.Integer`, for example, you could get the `Class` object for `java.lang.Integer` simply by invoking `getClass()` on your reference to the `Integer` object.

Given a reference to a `Class` object, you can find out information about the type by invoking methods declared in class `Class`. If you look at these methods, you will quickly realize that class `Class` gives the running application access to the information stored in the method area. Here are some of the methods declared in class `Class`:

```java
// Some of the methods declared in class java.lang.Class:
public String getName();
public Class getSuperClass();
public boolean isInterface();
public Class[] getInterfaces();
public ClassLoader getClassLoader();
```

These methods just return information about a loaded type. `getName()` returns the fully qualified name of the type. `getSuperClass()` returns the `Class` instance for the type's direct superclass. If the type is class `java.lang.Object` or an interface, none of which have a superclass, `getSuperClass()` returns null. `isInterface()` returns true if the `Class` object describes an interface, false if it describes a class. `getInterfaces()` returns an array of `Class` objects, one for each direct superinterface. The superinterfaces appear in the array in the order they are declared as superinterfaces by the type. If the type has no direct superinterfaces, `getInterfaces()` returns an array of length zero. `getClassLoader()` returns a reference to the `ClassLoader` object that loaded this type, or null if the type was loaded by the bootstrap class loader. All this information comes straight out of the method area.

#### Method Tables

The type information stored in the method area must be organized to be quickly accessible. In addition to the raw type information listed previously, implementations may include other data structures that speed up access to the raw data. One example of such a data structure is a method table. For each non-abstract class a Java virtual machine loads, it could generate a method table and include it as part of the class information it stores in the method area. A method table is an array of direct references to all the instance methods that may be invoked on a class instance, including instance methods inherited from superclasses. (A method table isn't helpful in the case of abstract classes or interfaces, because the program will never instantiate these.) A method table allows a virtual machine to quickly locate an instance method invoked on an object. Method tables are described in detail in Chapter 8, "The Linking Model."

#### An Example of Method Area Use

As an example of how the Java virtual machine uses the information it stores in the method area, consider these classes:

```java
// On CD-ROM in file jvm/ex2/Lava.java
class Lava {

    private int speed = 5; // 5 kilometers per hour

    void flow() {
    }
}

// On CD-ROM in file jvm/ex2/Volcano.java
class Volcano {

    public static void main(String[] args) {
        Lava lava = new Lava();
        lava.flow();
    }
}
```

The following paragraphs describe how an implementation might execute the first instruction in the bytecodes for the `main()` method of the `Volcano` application. Different implementations of the Java virtual machine can operate in very different ways. The following description illustrates one way--but not the only way--a Java virtual machine could execute the first instruction of `Volcano's main()` method.

To run the `Volcano` application, you give the name "`Volcano`" to a Java virtual machine in an implementation-dependent manner. Given the name `Volcano`, the virtual machine finds and reads in file `Volcano.class`. It extracts the definition of class `Volcano` from the binary data in the imported class file and places the information into the method area. The virtual machine then invokes the `main()` method, by interpreting the bytecodes stored in the method area. As the virtual machine executes `main()`, it maintains a pointer to the constant pool (a data structure in the method area) for the current class (class `Volcano`).

Note that this Java virtual machine has already begun to execute the bytecodes for `main()` in class `Volcano` even though it hasn't yet loaded class Lava. Like many (probably most) implementations of the Java virtual machine, this implementation doesn't wait until all classes used by the application are loaded before it begins executing `main()`. It loads classes only as it needs them.

`main()'`s first instruction tells the Java virtual machine to allocate enough memory for the class listed in constant pool entry one. The virtual machine uses its pointer into Volcano's constant pool to look up entry one and finds a symbolic reference to class `Lava`. It checks the method area to see if `Lava` has already been loaded.

The symbolic reference is just a string giving the class's fully qualified name: "`Lava`". Here you can see that the method area must be organized so a class can be located--as quickly as possible--given only the class's fully qualified name. Implementation designers can choose whatever algorithm and data structures best fit their needs--a hash table, a search tree, anything. This same mechanism can be used by the static `forName()` method of class `Class`, which returns a `Class` reference given a fully qualified name.

When the virtual machine discovers that it hasn't yet loaded a class named "`Lava`," it proceeds to find and read in file Lava.class. It extracts the definition of class `Lava` from the imported binary data and places the information into the method area.

The Java virtual machine then replaces the symbolic reference in `Volcano`'s constant pool entry one, which is just the string "`Lava`", with a pointer to the class data for `Lava`. If the virtual machine ever has to use `Volcano`'s constant pool entry one again, it won't have to go through the relatively slow process of searching through the method area for class `Lava` given only a symbolic reference, the string "`Lava`". It can just use the pointer to more quickly access the class data for `Lava`. This process of replacing symbolic references with direct references (in this case, a native pointer) is called constant pool resolution. The symbolic reference is resolved into a direct reference by searching through the method area until the referenced entity is found, loading new classes if necessary.

Finally, the virtual machine is ready to actually allocate memory for a new `Lava` object. Once again, the virtual machine consults the information stored in the method area. It uses the pointer (which was just put into `Volcano`'s constant pool entry one) to the `Lava` data (which was just imported into the method area) to find out how much heap space is required by a `Lava` object.

A Java virtual machine can always determine the amount of memory required to represent an object by looking into the class data stored in the method area. The actual amount of heap space required by a particular object, however, is implementation-dependent. The internal representation of objects inside a Java virtual machine is another decision of implementation designers. Object representation is discussed in more detail later in this chapter.

Once the Java virtual machine has determined the amount of heap space required by a `Lava` object, it allocates that space on the heap and initializes the instance variable speed to zero, its default initial value. If class `Lava`'s superclass, `Object`, has any instance variables, those are also initialized to default initial values. (The details of initialization of both classes and objects are given in Chapter 7, "The Lifetime of a Type.")

The first instruction of `main()` completes by pushing a reference to the new Lava object onto the stack. A later instruction will use the reference to invoke Java code that initializes the speed variable to its proper initial value, five. Another instruction will use the reference to invoke the `flow()` method on the referenced `Lava` object.

## Heap

## The Program Counter

## The Java Stack

## Native Method Stacks

## Execution Engine

## Native Method Interface

## 참조
- [The Java® Virtual Machine Specification](https://docs.oracle.com/javase/specs/jvms/se7/html/){: target="_blank" }
- [The Java Virtual Machine - artima](https://www.artima.com/insidejvm/ed2/jvm.html){: target="_blank" }