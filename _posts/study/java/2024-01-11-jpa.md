---
title: "JPA(Java Persistence API)"
categories: [공부, JPA]
tags: [JPA, EntityManagerFactory, EntityManager, Persistence Context, 영속성 컨텍스트]
---

# JPA(Java Persistence API)

## 개발 환경
- OS: Windows 11 Home
- IDE: Eclipse
- Java VERSION: JDK 17
- Database: Maria DB

## JPA(Java Persistence API)란?

![01-jpa](/assets/img/posts/study/java/jpa/01-jpa.png)

- Java Persistence API의 약자로 자바의 ORM(Object Relational Mapping) 표준 스펙을 정의하는 인터페이스 모음
- JPA의 스펙은 자바의 객체와 데이터베이스를 어떻게 매핑하고 동작해야 하는지를 정의하고 있음
- 즉, 실제로 구현된 것이 아니라 구현된 객체와 매핑을 해주기 위해 사용되는 프레임워크

## 하이버네이트(Hibernate)

![02-hibernate](/assets/img/posts/study/java/jpa/02-hibernate.png)

- ORM Framework
- JPA의 실제 구현체 중 하나이며, 현재 JPA 구현체 중 가장 많이 사용됨
- 따라서 JPA를 사용하려면 JPA 인터페이스를 구현한 특정한 라이브러리(예: Hibernate, EclipseLink, Apache OpenJPA 등)를 프로젝트에 추가해주어야 함

## 영속성 컨텍스트(Persistence Context)

![03-persistence-context](/assets/img/posts/study/java/jpa/03-persistence-context.png)

- JPA가 관리하고 영속화(DB에 저장)시키는 논리적 영역이자 Entity 객체의 집합
- Entity 객체가 영속성 컨텍스트에 들어오게 되어 관리 대상이 되면 그 객체를 영속 객체(Persistence Object)라고 부름
- **영속성 컨텍스트는 `EntityManager`가 생성될 때 생성되고, 영속성 컨텍스트에 접근하기 위해서 `EntityManager`를 사용함**

### EntityManager
- Entity 객체가 영속성 컨텍스트에 들어오게 되면 JPA는 Entity 객체의 매핑 정보를 가지고 필요에 따라 DB의 데이터를 저장, 조회, 수정, 삭제할 수 있고, 이러한 작업을 담당하는 객체를 `EntityManager`라고 함
	+ **즉, Entity 객체가 영속석 컨텍스트에 들어왔다고해서 반드시 '영속화'되는 것이 아니라 영속화될 가능성이 있을 뿐임**
- `EntityManager`를 통한 **저장, 조회, 수정, 삭제와 같은 작업들은 반드시 트랜잭션 내에서 이루어져야 함**
	- 다르게 말하면, 요청(트랜잭션)이 있을 때마다 `EntityManager`를 생성해야 함
	- 트랜잭션 내에서 작업하지 않은 작업 내용은 DB에 커밋되지 않음
		+ 커밋되지 않은 트랜잭션은 롤백되어 변경사항이 취소됨
- `EntityManagerFacotry`를 통해 생성됨
- **여러 thread가 동시에 접근할 경우 동시성 문제가 발생하게 되므로, `EntityManager`를 공유해서는 안됨**
	- `EntityManagerFactory`는 여러 thread가 동시에 접근하여도 안전(Thread-Safe)

> 읽기 전용 트랜잭션(Read-Only Transaction)에서는 데이터를 조회만 하고 수정하지 않기 때문에 트랜잭션이 필수적이지 않을 수 있다. 하지만 보통은 데이터베이스 작업은 트랜잭션 내에서 이루어지는 것이 안전하며, 이를 통해 일관성과 격리성을 보장할 수 있다.
{: .prompt-tip }

> 스프링 프레임워크에서는 스프링 컨테이너가 시작될 때 `EntityManager`를 생성하여 빈으로 등록하고, 이를 `@PersistenceContext` 어노테이션을 사용하여 주입받을 수 있다(또는 `@Autowired` 어노테이션을 사용하여 `EntityManagerFactory`를 주입받은 후 직접 `EntityManager`를 생성할 수도 있다). 싱글톤 기반으로 동작는 스프링에서 빈은 모든 thread에서 공유되지만, `@PersistenceContext` 어노테이션으로 주입받은 `EntityManager`는 Proxy를 통해서 감싸고 `EntityManager`를 호출할 때 마다 Proxy를 통해 새로운 `EntityManager`를 생성하기 때문에 Thread-Safe를 보장받는다.
{: .prompt-info }

#### EntityManager 동작 방식

1. `EntityManagerFactory`를 통해 `EntityManager` 생성(이때 영속성 컨텍스트가 생성됨)
2. `EntityManager`가 가지고 있는 트랜잭션(Transaction)을 시작
3. `EntityManager`를 통해 영속성 컨텍스트에 접근(CRUD)하고 객체를 작업
4. 트랜잭션을 커밋(Commit)하여 DB에 반영
5. `EntityManager` 종료(이때 영속성 컨텍스트가 종료됨)

> 4번 단계인 트랜잭션을 커밋하기 이전까지의 작업들은 DB에 반영이 안된다고 생각할 수 있지만, ID 생성 전략을 사용할 때 특히 `@GeneratedValue` 어노테이션을 사용하는 경우에는 `EntityManager`가 트랜잭션을 커밋하지 않은 상태임에도 불구하고 DB에 접근한다.
{: .prompt-tip }

### 영속성 컨텍스트 영역

![04-persistence-context-area(1)](/assets/img/posts/study/java/jpa/04-persistence-context-area(1).png)
*위 그림은 영속성 컨텍스트의 구조를 간단하게 도식화한 것이다.*

#### 1차 캐시 저장소

- `EntityManager`가 관리하는 Entity 캐시들을 저장(Entity가 영속 상태가 됨)이 되는 곳
	* **영속 상태에서는 commit되기 전까지 변경사항이 DB에 반영되지 않으며, 단순히 영속성 컨텍스트에서 관리(managed)되고 있음**
- 일반적으로 Map 형태로 저장되며, Map의 Key는 Entity의 식별자(`@Id`)이고 Value는 해당 Entity 객체 자체

##### 1차 캐시 저장소의 특징

- 캐시 저장
	+ **`EntityManger`를 통해 영속성 컨텍스트에 들어온 영속 객체는 1차 캐시에 저장**
	+ 이 캐시에 저장된 영속 객체는 유일한 식별자(`@Id`)를 기반으로 구분됨

- 동일성 보장
	+ 1차 캐시는 영속 객체의 동일성을 보장
	+ **동일한 식별자(`@Id`)를 가진 영속 객체가 여러 번 조회되더라도 처음 조회한 영속 객체를 재사용하여 동일한 객체를 반환**

- 성능 향상
	+ 조회하고자하는 데이터가 1차 캐시에 이미 저장되어 있는 경우, 저장되어 있는 영속 객체를 활용함으로써 중복된 DB접근을 피하고 성능을 향상시킬 수 있음
	+ 조회하고자하는 데이터가 1차 캐시에 저장되어 있지 않은 경우, DB에서 조회한 후 영속 객체를 1채 캐시에 저장한 뒤 영속 객체를 반환

- 트랜잭션 범위
	+ **1차 캐시는 트랜잭션 범위 내에서만 유효**
	+ **트랜잭션 외부에서 발생한 1차 캐시의 변경사항들은 DB에 반영되지 않음**

#### 쓰기 지연 sql 저장소

- DB에서 Entity를 변경하는 작업을 지연시키고 나중에 일괄적으로 처리하는 메커니즘

```java
EntityManager entityManager = entityManagerFactory.createEntityManager();

User user1 = new User();
User user2 = new User();

entityManager.getTransaction().begin();

entityManager.persist(user1); // 새로운 Entity 저장
entityManager.persist(user2); // 새로운 Entity 저장

entityManager.getTransaction().commit();
```

위 코드는 크게 다음과 같은 단계로 실행된다.

![05-persistence-context-area(2)](/assets/img/posts/study/java/jpa/05-persistence-context-area(2).png)

- `persist(user1)`
	1. 영속성 컨텍스트의 1차 케시에 user1 객체 저장
	2. JPA 프로바이더(Hibernate)가 `INSERT` 쿼리문을 생성하여 쓰기 지연 sql 저장소에 저장

![06-persistence-context-area(3)](/assets/img/posts/study/java/jpa/06-persistence-context-area(3).png)

- `persist(user2)`
	1. 영속성 컨텍스트의 1차 케시에 user2 객체 저장
	2. JPA 프로바이더(Hibernate)가 `INSERT` 쿼리문을 생성하여 쓰기 지연 sql 저장소에 저장

![07-persistence-context-area(4)](/assets/img/posts/study/java/jpa/07-persistence-context-area(4).png)

- `commit()`
	1. `EntityManager`가  `flush()` 메서드를 호출하여 쓰기 지연 sql 저장소에 쌓여있는 쿼리들을 DB에 전달(영속성 컨텍스트의 변경 내용을 DB와 동기화)
	1. **이때 1차 캐시들은 초기화되지 않음**
	2. 커밋

> Entity가 영속성 객체에 저장될 때마다 쓰기 지연 sql 저장소에 쿼리문이 저장되는 것인지, `commit()`이 되고 `flush()` 메서드가 호출될 때 쿼리문이 쓰기 지연 sql 저장소에 저장되는 것인지 의문이 들어 검색을 해보았지만 답을 찾지 못하였습니다. 크게 중요한 내용은 아니지만, 위 설명이 잘못된 정보를 전달할 수도 있을 것 같아 이렇게 명시합니다.
{: .prompt-info }

#### <a id="anchor1">변경 감지(Dirty Checking)</a>

```java
EntityManager entityManager = entityManagerFactory.createEntityManager();

entityManager.getTransaction().begin();

User user = entityManager.find(User.class, 1L); // 영속성 컨텍스트에 저장

user.setAge(20); // 영속 객체의 필드 변경

entityManager.getTransaction().commit(); // 변경(update)된 내용이 DB에 반영됨
```

- `EntityManager`가 영속 객체의 상태 변화를 추적하여 변경 사항이 있는지 여부를 확인하는 메커니즘
	+ Entity가 영속성 컨텍스트에 저장될 때 해당 Entity의 스냅샷(최초 상태)을 유지하는데, 트랜잭션 내에 Entity(영속 객체)의 상태가 변경될 때마다 Dirty Checking이 수행됨
	+ 트랜잭션이 커밋되기 전에 영속성 컨텍스트에 있는 영속 객체의 현재 상태와 스냅샷을 비교하여 변경된 속성을 감지하고 `UPDATE` 쿼리문을 생성하여 쓰기 지연 sql 저장소에 저장
	+ 이후 트랜잭션이 `commit()`되고 `EntityManager`가 `flush()` 메서드를 호출하여 쓰기 지연 sql 저장소에 저장되어 있는 `UPDATE` 쿼리문을 DB에 전달하여 동기화

> 영속 객체가 변경될 때마다 Dirty Checking이 수행되어 쓰기 지연 sql 저장소에 쿼리문이 저장되는 것인지, `commit()`이 되고 `flush()` 메서드가 호출될 때 Dirty Checking이 수행되어 쓰기 지연 sql 저장소에 저장되는 것인지 의문이 들어 검색을 해보았지만 답을 찾지 못하였습니다. 크게 중요한 내용은 아니지만, 위 설명이 잘못된 정보를 전달할 수도 있을 것 같아 이렇게 명시합니다. 마침, 저와 비슷한 의문을 가지신 분의 [글](https://www.inflearn.com/questions/685350/%EB%B3%80%EA%B2%BD-%EA%B0%90%EC%A7%80%EA%B0%80-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%8B%9C%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EA%B6%81%EA%B8%88%ED%95%9C-%EC%A0%90%EC%9D%B4-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4){: target="_blank" }을 첨부할테니 참고하시길 바랍니다.
{: .prompt-info }

### 영속

- Entity가 영속성 컨텍스트에 저장된 상태
- Entity가 `EntityManger`에 의해 관리되는 상태
- **영속 상태에 놓인 Entity의 변경사항은 트랜잭션이 commit될 때 DB에 반영됨**

#### Entity가 영속화되는 시점

`EntityManager`를 통해 조회(Query) 또는 find() 메서드를 호출할 때

```java
EntityManager entityManager = entityManagerFactory.createEntityManager();

entityManager.getTransaction().begin();

User user1 = entityManager.find(User.class, 1L); // EntityManager를 통한 조회
User user2 = entityManager.find(User.class, 1L); // EntityManager를 통한 조회

System.out.println(user1 == user2) // true

entityManager.getTransaction().commit();
```

새로운 Entity 객체를 생성하고 `EntityManager`를 통해 저장할 때

```java
EntityManager entityManager = entityManagerFactory.createEntityManager();

User user = new User();
user.setName("drj9812");

entityManager.getTransaction().begin();

entityManager.persist(user); // 새로운 Entity 저장

entityManager.getTransaction().commit();
```

> 영속성 컨텍스트에 들어온 적이 없는 Entity를 삭제하려고 시도하면, JPA는 해당 Entity가 영속성 컨텍스트에 관리되지 않았다는 예외를 발생시킨다. 즉, JPA에서 Entity를 삭제하려면 해당 Entity가 영속성 컨텍스트에 이미 존재해야 한다.
{: .prompt-info }

#### 준영속

영속성 컨텍스트에 저장되어 있다가 분리되어 관리되지 않는 상태

```java
EntityManager entityManager = entityManagerFactory.createEntityManager();

entityManager.getTransaction().begin();

User user1 = entityManager.find(User.class, 1L); // EntityManager를 통한 조회(영속 상태)
User user2 = entityManager.find(User.class, 1L); // EntityManager를 통한 조회(영속 상태)

entityManager.detach(user1); // 준영속 상태

System.out.println(user1 == user2); // false

entityManager.getTransaction().commit();
```

```java
EntityManager entityManager = entityManagerFactory.createEntityManager();

entityManager.getTransaction().begin();

User user = entityManager.find(User.class, 1L); // EntityManager를 통한 조회(영속 상태)

entityManager.clear(); // 준영속 상태

entityManager.getTransaction().commit();
```

#### 삭제

영속성 컨텍스트에서 분리되고 DB에서 삭제된 상태

```java
EntityManager entityManager = entityManagerFactory.createEntityManager();

entityManager.getTransaction().begin();

User user = entityManager.find(User.class, 1L); // EntityManager를 통한 조회(영속 상태)

entityManager.remove(user); // 삭제 상태

entityManager.getTransaction().commit();
```

### 엔터티(Entity) 클래스

JPA 어노테이션을 활용하여 엔터티 클래스를 정의하는데, 주요 어노테이션은 아래와 같음

- `@Entity`
	* 해당 클래스가 JPA 엔터티 클래스라고 정의
	* DB 테이블과 매핑되는 클래스
	* JPA를 사용할 수 있는 환경에서는 어떤 JPA 구현체를 사용하더라도 이 어노테이션을 사용할 수 있음
- `@Table`
	* 해당 클래스가 DB의 어느 테이블에 매핑되는지 정의
	* 해당 클래스가 DB의 테이블 이름과 다를 때 name 속성을 사용하여 사용됨(같을 경우 사용안해도 됨)
	* name 속성이 없을 경우 JPA는 해당 클래스와 동일한 이름의 테이블을 DB에서 찾음
- `@Id`
	* DB 테이블의 Primary Key 컬럼과 매핑
	* **JPA에서 사용하는 클래스에는 반드시 ID(Primary Key)가 있어야 함**
	* `strategy` 속성
		+ `GenerationType.INDENTITY`: 생성 타입을 자동증가(Auto IncrentityManagerent)로 설정(MySQL, MariaDB, PostgreSQL 등)
		+ `GenerationType.SEQUENCE`: 생성 타입을 시퀀스(SEQUENCE)로 설정(Oracle, PostgreSQl, DB2, H2 등)
		+ `GenerationType.TABLE`: 테이블을 사용하여 시퀀스(SEQUENCE) 값을 생성(모든 DB)
- `@Column`
	* 매핑할 DB의 컬럼 이름과 필드의 이름이 다를 경우 `name` 속성을 사용하여 매핑
	* 필드의 이름과 DB의 컬럼 이름이 일치하는 경우에는 명시하지 않아도 됨
	* `nullable` 속성
		+ `NOT NULL` 제약 조건 설정
	* `unique` 속성
		+ `UNIQUE` 제약 조건 설정

## Maven, JPA 설정

pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchentityManagera-instance"
  xsi:schentityManageraLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  
  <modelVersion>4.0.0</modelVersion>
  <groupId>studio.aroundhub</groupId>
  <artifactId>basic_JPA</artifactId>
  <version>1.0.0</version>

  <properties>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
  </properties>

  <dependencies>
	  
    <!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-core</artifactId>
      <version>5.6.1.Final</version>
    </dependency>

    <!-- https://mvnrepository.com/artifact/org.mariadb.jdbc/mariadb-java-client -->
    <dependency>
      <groupId>org.mariadb.jdbc</groupId>
      <artifactId>mariadb-java-client</artifactId>
      <version>2.7.3</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.8.1</version>
        <configuration>
          <source>17</source>
          <target>17</target>
          <encoding>utf-8</encoding>
        </configuration>
      </plugin>
    </plugins>
  </build>

</project>
```

persistence.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>

<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence"
  xmlns:xsi="http://www.w3.org/2001/XMLSchentityManagera-instance"
  xsi:schentityManageraLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"
  version="2.1">

  <persistence-unit name="영속성 유닛 이름" transaction-type="RESOURCE_LOCAL">

    <properties>
      <!-- 필수 속성 시작 -->
      <property name="javax.persistence.jdbc.driver" value="org.mariadb.jdbc.Driver"/>
      <property name="javax.persistence.jdbc.user" value="사용자 이름"/>
      <property name="javax.persistence.jdbc.password" value="사용자 암호"/>
      <property name="javax.persistence.jdbc.url" value="DB 연결 URL"/>

      <property name="hibernate.dialect" value="org.hibernate.dialect.MariaDB103Dialect"/>
      <!-- 필수 속성 끝 -->

      <property name="hibernate.hbm2ddl.auto" value="create"/>

      <property name="hibernate.show_sql" value="true"/>
      <property name="hibernate.format_sql" value="true"/>

    </properties>

  </persistence-unit>

</persistence>
```

- `<persistence></persistence>`
	+ 루트 태그
- `<persistence-unit>`
	+ 영속성 유닛 정의
	+ `name` 속성
		* **연동될 DB 하나당 하나의 유닛으로 설정**(2개 이상의 DB를 사용한다면 `persistence-unit` 또한 2개 이상을 지정해줘야 함)하고, `name` 속성을 사용하여 유닛마다 고유한 이름을 명시해줘야 함
		* `name`속성으로 정의한 이름은 `EntityManagerFactory`를 생성할 때 사용됨
	+ `<persistence-unit>` 태그 내부에 각 Entity 클래스를 `<class>User</class>`와 같이  `<class>` 엘리먼트를 사용하여 명시하면 JPA 프로바이더(예: Hibernate)가 해당 Entity 클래스를 스캔하고 관리함
		* `<persistence-unit>` 태그 내부에 JPA에서 사용할 Entity 클래스들을 명시하지 않고 Entity 클래스에 `@Entity` 어노테이션을 사용하여 해당 클래스가 Entity 클래스임을 명시할 수도 있음
	+ `transaction-type` 속성
		* 트랜잭션의 유형을 지정
		* `JTA`: Java Transaction API를 사용한 트랜잭션 관리(JAVA EE 환경에서 주로 사용)
		* `RESOURCE_LOCAL`: 애플리케이션에서 직접 트랜잭션을 관리(Java SE나 JAVA EE에서 사용)

> 스프링과 스프링 부트 프레임워크에서는 `@Entity` 어노테이션을 사용하여 JPA Entity 클래스를 표시하면, 스프링의 자동 설정과 컴포넌트 스캔 기능(`@SpringBootApplication` 어노테이션이 위치한 패키지부터 하위 패키지까지)에 의해 해당 Entity 클래스는 자동으로 JPA에 의해 관리되고, `Persistence Context`에 등록된다. 따라서 스프링을 사용한다면, 이러한 명시적인 등록이 대부분 자동으로 처리되므로 별도의 `persistence.xml` 파일이 크게 필요하지 않다.
{: .prompt-info }

- <properties></properties>
	+ `Persistence Unit`의 속성들을 정의
	+ `<property name="javax.persistence.jdbc.driver" value="org.mariadb.jdbc.Driver"/>`
		* 사용할 드라이브 클래스
	+ `<property name="javax.persistence.jdbc.user" value="사용자 이름"/>`
		* 사용자 이름
	+ `<property name="javax.persistence.jdbc.password" value="사용자 암호"/>`
		* 사용자 암호
	+ `<property name="javax.persistence.jdbc.url" value="DB 연결 URL"/>`
		* DB 연결 URL
	+ `<property name="hibernate.dialect" value="org.hibernate.dialect.MariaDB103Dialect"/>`
		* Hibernate가 사용할 SQL 방언 지정
	+ `<property name="hibernate.hbm2ddl.auto" value="create"/>`
		* **애플리케이션을 시작할 때마다 Hibernate가 기존 스키마를 삭제하고 새로운 스키마를 생성**
		* 이미 존재하는 DB를 완전히 재생성
	+ `<property name="hibernate.show_sql" value="true"/>`
		* Hibernate가 실행하는 SQL 문장이 로그로 `System.out`에 출력
	+ `<property name="hibernate.format_sql" value="true"/>`
		* 생성된 SQL을 보기 좋게 포맷팅

> 개발 초기 단계 및 테스트 환경에서는 `hibernate.hbm2ddl.auto` 옵션을 `create` 또는 `update`, 테스트 서버에서는 `update` 또는 `validate`, 스테이징 및 운영 서버에서는 `validate` 또는 `none` 옵션을 사용하는 것이 좋다.
{: .prompt-tip }

> 스키마가 완성되어 `validate` 또는 `none` 옵션 등을 사용하는 환경에서 `create` 옵션을 사용하게 된다면 그 즉시 DB의 데이터가 모두 날라가므로 주의해야 한다.
{: .prompt-warning }

## JPA 동작 확인

### 구조 및 코드

![08-basic_jpa-project-structure](/assets/img/posts/study/java/jpa/08-basic_jpa-project-structure.png)

UserEntity.java

```java
package studio.aroundhub.basic_JPA.entity;

import java.time.LocalDateTime;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "user")
public class UserEntity {

    @Id // primary Key
    private String email;
    private String name;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public UserEntity() {}

    public UserEntity(String email, String name, LocalDateTime createdAt, LocalDateTime updatedAt) {
    	this.email = email;
    	this.name = name;
    	this.createdAt = createdAt;
    	this.updatedAt = updatedAt;
    }
    
    public String getemail() {
        return email;
    }

    public String getName() {
        return name;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
}
```

> 기본생성자는 JPA 엔터티 클래스에서 필요한 요소 중 하나다. 엔터티를 영속화하거나 검색할 때, JPA를 구현하는 Hibernate는 내부적으로 `constructor.newInstance()` 라는 `Reflection`을 이용해 해당 Entity의 기본 생성자를 호출해서 객체를 생성하게 되는데, 이 `Reflection`은 생성자의 파라미터를 읽을 수가 없어서 반드시 파라미터가 없는 기본 생성자를 정의해 줘야 한다. 따라서 JPA를 사용하는 경우, 엔터티 클래스에는 기본생성자를 명시적으로 추가하는 것이 권장된다.
{: .prompt-info }

BasicJPAApplication.java

```java
package studio.aroundhub.basic_JPA;

import java.time.LocalDateTime;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.EntityTransaction;
import javax.persistence.Persistence;
import studio.aroundhub.basic_JPA.entity.UserEntity;

public class BasicJPAApplication {
    public static void main(String[] args) {

        // EntityManagerFactory는 EntityManager를 생성하기 위한 팩토리 인터페이스로 persistence 단위별로 팩토리를 생성
        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("영속성 유닛 이름"); // persistence.xml 파일에 기입한 이름을 적어줘야 함

        System.out.println("Check 1");

        // EntityManager 객체를 생성
        // EntityManager는 Persistence Context와 Entity를 관리
        EntityManager entityManager = entityManagerFactory.createEntityManager();

        System.out.println("Check 2");

        // EntityManager에서 트랜잭션을 가져와 관리하기 위한 객체 생성
        EntityTransaction entityTransaction = entityManager.getTransaction();

        System.out.println("Check 3");

        try {
            // 트랜잭션을 시작해야 DB를 조작할 수 있음
            entityTransaction.begin();

            System.out.println("Check 4");

            // 저장하고자 하는 엔티티 객체를 생성
            UserEntity userEntity = new UserEntity("drj9812@gmail.com", "drj9812", LocalDateTime.now(), LocalDateTime.now());

            System.out.println("Check 5");

            // UserEntity 객체를 Persistence Context에 추가
            entityManager.persist(userEntity);

            System.out.println("Check 6");

            // 실제 DB에 반영
            entityTransaction.commit();

            System.out.println("Check 7");

        } catch (Exception e) {
            e.printStackTrace();

            // 예외가 발생했을 경우 트랜잭션 롤백 진행
            entityTransaction.rollback();

        } finally {
            // 엔티티 매니저 종료. JDBC에서 Connection 종료하는 것과 동일한 기능으로 보면 됨
            entityManager.close();
        }

        System.out.println("Check 8");

        // 팩토리 종료. 커넥션 풀 자원을 반환
        entityManagerFactory.close();

    }
}
```

![09-run-basicjpaapplication](/assets/img/posts/study/java/jpa/09-run-basicjpaapplication.png)
*실행*

![10-basicjpaapplication-result](/assets/img/posts/study/java/jpa/10-basicjpaapplication-result.png)
*실행 결과*

## EntityManagerFacotory 커스터마이징

### 필요성

레이어드 아키텍처(Layered Architecture)에서 `EntityManagerFactory`를 Data Access 단뿐만 아니라 그 윗단(Presentation, Business)으로 올라가서 사용해야하는 경우가 생길 수 있는데, 그럴 때마다 그 윗단에서 `EntityManagerFactory`를 생성하고 또 영속석 컨텍스트를 유지시키기 위해 아랫단에 `EntityManagerFactory`를 매개변수로 넘겨주는 것은 번거롭기 때문에 static한 클래스를 생성하여 `EntityManagerFactory`와 `EntityManager`를 관리하는 것이 편리하다.

### 구조 및 코드

![11-entity_manager_factory-project-structure](/assets/img/posts/study/java/jpa/11-entity_manager_factory-project-structure.png)

UserEntity.java

```java
package studio.aroundhub.entity_manager_factory.entity;

import java.time.LocalDateTime;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "user")
public class UserEntity {

    @Id
    private String email;
    private String name;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public UserEntity(String email, String name, LocalDateTime createdAt, LocalDateTime updatedAt) {
    	this.email = email;
    	this.name = name;
    	this.createdAt = createdAt;
    	this.updatedAt = updatedAt;
    }
    
    public UserEntity() {}

    public String getEmail() {
        return email;
    }

    public String getName() {
        return name;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }
}
```

CEntityManagerFactory.java

```java
package studio.aroundhub.entity_manager_factory.factory;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class CEntityManagerFactory {

    private static EntityManagerFactory entityManagerFactory;

    /**
     * EntityManagerFactory는 EntityManager를 생성하기 위한 팩토리 인터페이스로 persistence 단위별로 팩토리를 생성
     */
    public static void initialization() {
        entityManagerFactory = Persistence.createEntityManagerFactory("영속성 유닛 이름");
    }

    /**
     * EntityManager 객체를 생성
     * EntityManager는 Persistence Context와 Entity를 관리
     *
     * @return EntityManager 객체
     */
    public static EntityManager createEntityManger() {
        return entityManagerFactory.createEntityManager();
    }

    /**
     * EntityManagerFactory 객체 종료
     */
    public static void close() {
        entityManagerFactory.close();
    }
}
```

EntityManagerFactoryApplication.java

```java
package studio.aroundhub.entity_manager_factory;

import java.time.LocalDateTime;
import javax.persistence.EntityManager;
import javax.persistence.EntityTransaction;
import studio.aroundhub.entity_manager_factory.entity.UserEntity;
import studio.aroundhub.entity_manager_factory.factory.CEntityManagerFactory;

public class EntityManagerFactoryApplication {
    public static void main(String[] args) {

        CEntityManagerFactory.initialization();
        EntityManager entityManager = CEntityManagerFactory.createEntityManger();

        // EntityManager에서 트랜잭션을 가져와 관리하기 위한 객체 생성
        EntityTransaction entityTransaction = entityManager.getTransaction();

        try {
            // 트랜잭션을 시작해야 DB를 조작할 수 있음
            entityTransaction.begin();

            // 저장하고자 하는 엔티티 객체를 생성
            UserEntity userEntity = new UserEntity("abc@naver.com", "abc", LocalDateTime.now(), LocalDateTime.now());

            // UserEntity 객체를 Persistence Context에 추가
            entityManager.persist(userEntity);

            // 실제 DB에 반영
            entityTransaction.commit();

        } catch (Exception e) {
            e.printStackTrace();

            // 예외가 발생했을 경우 트랜잭션 롤백 진행
            entityTransaction.rollback();

        } finally {
            // 엔티티 매니저 종료. JDBC에서 Connection 종료하는 것과 동일한 기능으로 보면 됨
            entityManager.close();
        }

        // 팩토리 종료. 커넥션 풀 자원을 반환
        CEntityManagerFactory.close();

    }
}
```

![12-run-entitymanagerfactoryapplication](/assets/img/posts/study/java/jpa/12-run-entitymanagerfactoryapplication.png)
*실행*

![13-entitymanagerfactoryapplication-result](/assets/img/posts/study/java/jpa/13-entitymanagerfactoryapplication-result.png)
*실행 결과*

## CRUD

### 데이터 추가하기

1. `EntityManagerFactory`를 통해 `EntityManager` 생성
2. `EntityManager`를 통해 `EntityTransaction` 시작
3. Entity 생성
4. EntityManager.psersist() 메서드를 통해 영속성 컨텍스트에 Entity 저장
5. EntityTransaction.commit() 메서드를 통해 DB에 실제 반영
	1. try-catch 문을 통해 3~5 단계에서 예외가 발생할 경우 transaction.rollback()
6. EntityManager.close() 종료

> Entity를 생성하는 단계는 유동적입니다.
{: .prompt-tip }

### 데이터 조회하기

1. `EntityManagerFactory`를 통해 `EntityManager` 생성
2. `EntityManager.find() 메서드를 통해 Entity 조회(영속성 컨텍스트에 Entity 저장)
3. EntityManager.close() 종료
4. 조회 성공
	1. 조회된 값이 없다면 `Null`

> 읽기 전용 트랜잭션(Read-Only Transaction)에서는 데이터를 조회만 하고 수정하지 않기 때문에 트랜잭션이 필수적이지 않을 수 있다. 하지만 보통은 데이터베이스 작업은 트랜잭션 내에서 이루어지는 것이 안전하며, 이를 통해 일관성과 격리성을 보장할 수 있다.
{: .prompt-tip }

### 데이터 변경하기

1. `EntityManagerFactory`를 통해 `EntityManager` 생성
2. `EntityManager`를 통해 `EntityTransaction` 시작
3. 변경하고자 하는 Entity 조회(영속성 컨텍스트에 Entity 저장)
4. 조회된 Entity 객체에서 값을 변경
5. EntityTransaction.commit() 메서드를 통해 변경 감지 및 DB에 실제 반영([Dirty Check](#anchor1))
	1. try-catch 문을 통해 3~5 단계에서 예외가 발생할 경우 transaction.rollback()
3. EntityManager.close() 종료

### 데이터 삭제하기

1. `EntityManagerFactory`를 통해 `EntityManager` 생성
2. `EntityManager`를 통해 `EntityTransaction` 시작
3. 삭제하고자 하는 Entity 조회(영속성 컨텍스트에 Entity 저장)
4. EntityManager.remove() 메서드를 통해 영속성 컨텍스트에서 영속 객체 삭제
5. EntityTransaction.commit() 메서드를 통해 변경 감지 및 DB에 실제 반영([Dirty Check](#anchor1))
	1. try-catch 문을 통해 3~5 단계에서 예외가 발생할 경우 transaction.rollback()
3. EntityManager.close() 종료

## 참조
- [JPA 기초 - 어라운드 허브 스튜디오](https://www.youtube.com/playlist?list=PLlTylS8uB2fAnOge-kDI0ZQxgj78bdTOO){: target="_blank" }