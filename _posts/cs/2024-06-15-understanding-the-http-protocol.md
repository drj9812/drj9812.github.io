---
title: "[CS]HTTP 프로토콜의 이해"
categories: [CS]
tags: [CS, HTTP, 프로토콜]
---

# HTTP 프로토콜의 이해

## HTTP란?

![01-tcp-ip-4-layer-model](/assets/img/posts/cs/web/understand-the-http-protocol/01-tcp-ip-4-layer-model.jpg)

![01-http-protocol](/assets/img/posts/cs/web/understand-the-http-protocol/01-http-protocol.jpg)

HTTP(Hyper Text Transfer Protocol) TCP/IP 4계층에서 애플리케이션 계층(Application Layer)에 해당하는 프로토콜로서, 전송 계층(Transport Layer)에서 TCP를 사용하여 웹 브라우저와 웹 서버 간에 통신하는 프로토콜이다. HTTP는 다음 그림과 같이 웹 브라우저와 웹 서버가 통신(요청, 응답)할 때 서로 약속된 요청, 응답 메시지를 주고받으면서 통신이 이루어진다.

- [TCP/IP 4계층](){ target="_blank" } 참조

## HTTP의 특징

### 무연결(Connectionless)

일반적으로 클라이언트가 서버와 통신하려면 연결을 유지한 상태에서 통신해야 한다. 그러나 HTTP는 연결을 유지하지 않은 상태로 데이터를 주고받을 수 있다. HTTP는 클라이언트로부터 요청이 들어와 서버가 응답하면 클라이언트와 서버의 연결을 끊고 클라이언트가 새로 요청하면 또 다른 연결을 맺는다. 이때의 연결은 이전과는 아무 상관이 없는 새로운 연결이다. 즉, HTTP는 클라이언트와 서버 간에 요청이 있을 때마다 독립적으로 연결하여 통신하는 방식이다. 그래서 클라이언트와 서버의 요청 단위로 새로운 연결을 처리해야 하는 단점이 있다.

### 무상태(Stateless)

HTTP는 무연결 특징이 있어서 요청이 있을 때마다 독립적인 트랜잭션으로 취급하기 때문에 이전 연결에서 했던 작업 내용을 다음 요청에서 그대로 사용할 수 없다. 이처럼 요청마다 서로 다른 연결로 인식되어 요청 간에 정보를 공유해서 사용할 수 없는 상태, 즉 상태정보가 유지되지 않는 특성을 무상태(Stateless)라고 한다. 그래서 HTTP를 사용하는 웹 프로그래밍에서는 이전 요청 시 사용한 정보를 다른 요청에서도 계속 사용하고 싶다면, 서버나 클라이언트 측에 정보를 저장해 두고 계속 상태정보를 유지한 후 사용하는 정보 유지기술이 필요하다.

### 요청·응답(Response·Response)

클라이언트가 서비스를 요청하면 서버는 요청 정보를 받고 요청을 처리한 후 응답함으로써 서비스가 완료되는 방식, 즉 요청정보와 응답정보를 주고받으며 통신이 이루어지는 방식을 요청·응답 또는 request-reply라고 한다. HTTP가 대표적인 요청·응답 방식이다.

이처럼 HTTP는 웹 클라이언트가 서버에 TCP 접속을 처리한 후에 요청 메시지를 보내면, 웹 서버는 요청 메시지를 근거로 서비스를 처리한 다음, 그 결과인 응답 메시지를 클라이언트에 보냄으로써 통신한다. 그래서 웹 서버 프로그래밍을 하려면 웹 서버와 클라이언트가 주고받는 요청 및 응답 메시지에 대한 이해가 우선적으로 이루어져야 한다.

## HTTP 요청 정보

HTTP 요청정보는 웹 클라이언트가 웹 서버에 서비스를 요청하면 HTTP에 의하여 자동으로 만들어져 서비스를 요청받은 웹 서버에 전달된다. 웹 클라이언트가 서비스를 요청한다는 것은 웹 브라우저 주소줄에 URL을 입력한 후 엔터 키를 누르거나 웹 브라우저 화면의 링크 또는 버튼을 클릭하는 동작을 말한다. 웹 브라우저에서 이러한 액션이 일어나면 HTTP는 요청정보를 생성하여 웹 서버에 전달함으로써 서비스 요청이 이루어지는데, 서비스 요청 시 전달되는 HTTP 요청정보는 다음과 같은 구조로 되어있다.

![02-http-request-info](/assets/img/posts/cs/web/understand-the-http-protocol/02-http-request-info.jpg)

HTTP 요청정보는 크게 헤더와 몸체로 구성되며 헤더의 가장 첫 번쨰 줄은 요청 줄(Request-Line)로서 3개의 정보가 들어간다. 첫 번째 정보는 요청방식이며 두 번째 정보는 요청한 페이지에 대한 정보인 URI다. 그리고 세 번째 정보는 요청 시 사용한 HTTP 버전 정보가 들어간다.

요청 줄 이후 공백 행이 삽입되며 다음 줄부터 헤더 정보다. 헤더 정보는 name : content 형식으로 정보들이 들어가며, 서비스 처리를 위한 웹 클라이언트와 웹 서버 간에 공유할 정보들이다. 헤더의 정보들이 끝난 다음에는 웹 클라이언트가 웹 서버에 보내는 데이터가 들어가는 메시지 몸체로 구성된다.

### HTTP 요청방식

#### GET

웹 서버에서 GET 방식으로 서비스를 요청하는 경우는 웹 브라우저의 주소 줄에 URL을 직접 입력하거나 하이퍼링크가 포함된 개체를 클릭할 때다. 또는 직접 GET 방식을 지정하여 서비스를 요청할 수도 있다. GET 방식의 요청은 브라우저에서 캐시(Cache)가 가능하며 클라이언트가 서버로 전송하는 문자열이 있을 때는 요청정보 헤더의 요청 줄에 포함되는 URI 뒤에 `?` 기호와 함께 추가되어 전달된다. 그래서 클라이언트에서 서버로 보내는 모든 문자열 정보들이 웹 브라우저에 노출되는 특징이 있으며, 헤더에 포함되므로 전달되는 문자열의 크기에 제한이 있다. GET은 가장 단순한 요청방식으로 서버에 빠른 속도로 요청할 때 사용한다.

#### POST

POSt 방식은 데이터가 HTTP 요청정보의 몸체에 포함되어 전달된다. 따라서 데이터 크기에 제한이 없고, 화면에 노출되지 않는다. 그러나 POST 방식은 웹 클라이언트 측에서 보내는 데이터를 인코딩하고, 서버 측에서 디코딩해야 하므로 GET 방식보다 상대적으로 처리속도가 느리다. POST 방식은 주로 서버 측의 정보를 새로 생성하는 작업에 사용한다.

#### PUT

PUT 방식의 서비스 요청은 파일 업로드를 할 때 이용할 수 있다. POST와 PUT 방식 모두 같은 작업을 수행할 수 있는데, 일반적으로 서버의 리소스를 새로 생성할 때(CREATE OR INSERT)는 POST 방식으로 요청하고, 서버의 리소스를 수정할 때(UPDATE)는 PUT 방식으로 구분하여 요청한다.

#### DELETE

서버의 리소스를 삭제하는 작업을 요청할 때(DELETE) 사용하는 방식이다.

#### OPTIONS

요청 URI에 대하여 허용되는 통신 옵션을 알고자 할 때 사용하는 방식이다.

#### HEAD

GET 방식과 같으나 요청정보의 몸체 없이 헤더 정보만 요청하는 방식이다. 해당 자원이 존재하는지, 또는 서버에 문제가 있는지를 확인하기 위해 사용한다.

#### TRACE

웹 클라이언트의 요청을 그대로 반환하는 방식으로 요청 정보가 웹 서버에 도달하기까지의 경로를 기록한다. TRACE 방식은 ECHO 서비스로 서버 상태를 확인하기 위한 목적으로 사용한다.

#### CONNECT

프록시(Proxy)에 사용하기 위해 예약된 메서드로서 프록시가 동적으로 접속할 수 있게 지원한다.

### 요청 URI

![URI](/assets/img/posts/cs/web/understand-the-http-protocol/)

요청 URI는 웹 클라이언트가 웹 서버에 요청한 서비스 문서의 정보다. 요청 URI는 네트워크의 자원 정보인 URL의 일부로서 URL(Uniform Resource Locator)은 네트워크상에 존재하는 자원을 찾아가기 위한 정보다.

#### 프로토콜(Protocol)

프로토콜은 서버와 통신하기 위한 규약으로서 서버마다 사용하는 프로토콜이 정해져 있다. 예를 들어, 웹 서버는 URL에 `HTTP://`로 표현하며 오라클 DBMS는 `jdbc:oracle:thin:@`으로 표현한다.

#### 서버 주소

네트워크상에서 연결된 컴퓨터를 찾아가기 위한 정보로서 IP 주소 또는 도메인 이름으로 표현한다. 서버가 동작하고 있는 컴퓨터 정보다.

#### 포트 번호

URL에서 서버 주소를 이용해 컴퓨터를 찾았다면 포트 번호는 컴퓨터에서 동작하고 있는 서버로 접속하기 위한 정보다. 포트 번호는 0 ~ 65,535번까지 사용할 수 있으며, 0 ~ 1,023 사이의 번호는 weel-known port로서 이미 사용이 정의되어 있다. 예를 들어, 웹 서버가 사용하는 포트 번호는 80포트로 정해져 있으며 만일 URL에서 HTTP 프로토콜로 접속 시 포트 번호를 생략하면 자동으로 80포트로 인식한다. 80포트 이외의 포트 번호를 웹 서버에 할당했을 때는 반드시 URL에 명시해 주어야 접속된다.

#### URI

URI(Uniform Resource Identifier)는 서버에서 서비스하는 서버의 자원 정보다. URL에서 포트 번호 다음부터가 URI다. 만일 `http://www.mysite.com:80/edu/index.html`과 같은 URL이 있다고 가정해보면, 먼저 `www.mysite.com`을 이용해 컴퓨터를 찾아오고, 다음 정보인 80을 이용해 서버를 찾아온다. 80 정보 다음부터가 접속한 서버에서 제공하는 자원정보로서 이것을 URI라고 한다. 웹 서버를 찾아오기까지 `www.mysite.com:80` 정보를 사용하고, URI 정보로 웹 서버에서 클라이언트가 요청한 문서를 찾아 실행한 후 결과를 또는 그 파일 자체를 클라이언트에 응답한다.

### 헤더(Header)

|      Accept     |                      text/html, application/xhtml+xml, application/xml;q=0.9, image/webp.*/*;q=0.8            |
| Accept-Encoding |                                             gzip, deflate, sdch                                               |
| Accept-Language |                                    ko-KR, ko;q=0.8, en-US;1=0.6, en;q=0.4                                     |
|   User-Agent    | Mozila/5.0(Windows NT 6.1; WOW64), AppleWebKit/537.36(KHTML, like Gecko), Chrome/51.0.2704.103, Safari/537.36 |
|  Cache-Control  |                                          No-cache, no-store, max-age                                          |

요청 줄 다음에는 헤더가 위치하는데, 헤더는 general-header, request-header, entity-header 3가지로 분류할 수 있으며, 클라이언트의 요청에 따라 필요한 헤더만 사용된다. 헤더에는 name : content의 형식으로 정보들이 표현되며 content 부분의 값들은 공백이나 탭으로 구분된다.

#### Accept

클라이언트가 인식하여 처리할 수 있는 파일 타입을 명시한다. 여러 개의 파일 타입은 쉼표(`,`)로 구분하여 나열한다.

#### Accept-Encoding

compress 또는 gzip과 같은 웹 클라이언트가 받아들일 수 있는 인코딩 방식을 지정한다. 여러 개의 인코딩 방식을 쉼표로 구분하여 나열한다. 만약 인코딩 형태를 지정하지 않으면 클라이언트에 어떤 형태도 받아들여지지 않는다.

#### Accept-Language

클라이언트가 지원하는 언어를 지정한다.

#### User-Agent

클라이언트가 사용하는 웹 브라우저에 대한 정보를 보여준다. 서버 쪽에서는 User-Agent 정보를 보고 싶은 일반 웹 페이지와 모바일 웹 페이지로 자동 분기한다.

#### Cache-Control

HTTP 캐시는 클라이언트가 서버에 요청하여 응답받은 서비스 결과를 클라이언트 쪽에 저장했다가 사용자로부터 같은 서비스 요청이 들어오면 이전에 저장된 처리결과를 보여주는 것을 말한다. 캐시는 클라이언트와 서버 사이에서 발생하는 작업을 생략함으로써 트래픽을 줄이고, 클라이언트는 응답을 빠르게 받을 수 있는 장점이 있다. Cache-Control에 다음과 같은 값을 설정할 수 있다.

- no-cache: 캐시 안 함
- no-store: 신속히 넘긴 후 정보 제거
- max-age = seconds: 지정된 시간보다 오래된 데이터는 캐시 안 함
- max-statle=seconds: 지정된 시간이 아직 되지 않은 만료된 데이터를 보냄
- min-fresh=seconds: 지정된 시간 이후의 변경된 새로운 데이터만 보냄
- only-if-cached: 새로운 데이터를 검색하지 않고 캐시에 있는 데이터만 반환

### HTTP 응답정보

![03-response-info](/assets/img/posts/cs/web/understand-the-http-protocol/03-response-info.jpg)

HTTP 응답정보의 상태 줄은 HTTP 버전, 상태 코드(Status-Code), 상태 코드 설명(Reason-Phrase)으로 구성되어 있다. HTTP 버전은 서버가 응답하기 위해 사용하는 HTTP 버전 정보이고, 상태 코드는 요청한 처리 결과를 숫자 세 자리로 나타내며, 상태 코드 설명은 처리 결과를 이해하기 쉬운 텍스트로 표현한 것이다.

#### 상태 코드(Status Code)

상태 코드는 클라이언트의 요청에 대한 처리 결과를 의미한다. 클라이언트는 응답정보 메시지를 받으면 상태 코드를 보고 처리 결과인 응답정보 메시지를 처리한다. 상태 코드는 3자리 숫자로 표현하며 가장 앞자리 숫자를 기준으로 응답정보 처리 결과를 분류할 수 있다. 1xx는 조건부 응답, 2xx는 성공, 3xx는 리다이렉션 완료, 4xx는 요청 오류, 5xx는 서버 오류에 관한 상태 코드다.

##### 200 OK

클라이언트의 요청을 성공적으로 처리했음을 나타내며, 서버는 요청한 데이터를 포함하여 응답한다. 응답하는 메시지는 요청한 요청방식에 따라 다르게 전달된다.

##### 400 Bad Request

클라이언트의 요청에 문법적인 오류 등 잘못된 요청으로 서버가 요청을 해석할 수 없는 경우다. 이런 경우는 잘못된 요청 형식을 수정하여 다시 요청해야 한다.

##### 401 Unauthorized

인증 오류(Unauthorized)로서 클라이언트가 잘못된 인증 정보를 Authorization 헤더에 넣었음을 나타낸다. 이런 경우 클라이언트는 요청정보 헤더의 Authorization에 적절한 인증 정보를 설정한 후 다시 요청해야 한다.

##### 403 Forbidden

사용자 허가 모드 오류(Forbidden)로서 클라이언트의 인증 정보에 상관없이 페이지에 대한 접근을 거부한다는 것을 나타낸다.

##### 404 Not Found

클라이언트가 요청한 문서가 존재하지 않음을 의미한다. 즉 클라이언트의 요청에 대하여 서비스하는 요청 URI를 서버가 찾지 못한 경우다.

#####  405 Method Not Allowed

클라이언트가 요청한 서비스 요청방식을 웹 서버에서 지원하지 않음을 의미한다. 이런 경우는 요청 한 서비스 요청방식을 확인한 후 서버 프로그램에 해당 요청방식 처리 메서드가 구현되어있는지를 확인한다.

##### 500 Internal Server Error

서버 ㅍ ㅡ로그램 실행 시 오류가 발생하여 서버 프로그램이 실행을 멈추었거나 올바르지 않은 응답 헤더 정보가 설정되어있을 때 발생한다. 일반적으로 서버 프로그램 실행 오류가 많으며, 이런 경우 서버 프로그램 내에서 구현의 오류를 찾아 수정해야 한다.

#### 헤더

|   Cache-Control  | public, private, no-cache, no-transform. must-revalidate, proxy-revalidate, max-age=seconds |
|     Connection   |                                               close                                         |
| Content-Encoding |                                                gzip                                         |
|    Content-Type  |                                     text/html; charset=UTF-8                                |
|        Date      |                                    Fri, 15 Jul 2016 23:06:23 GMT                            |
|       Server     |                                               nginx                                         |

상태 줄 다음에 헤더가 위치하는데, 클라이언트 서비스 요청에 대한 실행 결과를 웹 클라이언트가 올바르게 처리할 수 있게 하기 위한 정보들로 구성된다.

##### Cache-Control

HTTP1.1 버전에서 지원하느 헤더로서 응답 결과를 캐시에 저장할지에 관한 내용을 나타낸다. HTTP1.0 버전에서는 Pragma 이름으로 설정된다. 클라이언트가 요청할 때마다 페이지의 내용이 자주 바뀌지 않는 정적인 문서라면 빠른 속도 지원이 가능하도록 캐시를 사용하는 것이 좋고, 요청할 때마다 페이지의 내용이 자주 바뀐다면 캐시를 사용하지 않는 것이 효율적이다. 캐시 제어는 다음와 같은 값으로 설정할 수 있다.

- public: 어떠한 캐시라도 캐시할 수 있음
- private: 공유된 캐시는 캐시하지 않음
- no-cache: 캐시하지 않음
- no-transform: 데이터를 변환하지 않음
- must-revalidate: 클라이언트는 데이터를 재확인해야 함
- proxy-revalidate: 개인적인 클라이언트 캐시를 제외하고 데이터를 재확인해야 함

##### Connection

연결을 위해 지정하는 정보로서 close 연결은 클라이언트나 서버 둘 중 하나가 연결을 해제하기 원한다는 것을 알린다.

##### Content-Encoding

메시지를 전송할 때 사용할 인코딩 체계(Schema)를 지정한다. 값으로는 gzip 또는 x-gzip과 compress 또는 x-compress를 사용할 수 있다.

##### Content-Type

클라이언트가 요청한 메시지의 데이터 포맷으로서 서버도 같은 데이터 타입으로 처리하여 응답해야 한다.

##### Date

웹 서버가 클라이언트에 응답한 날짜와 시간을 표시한다.

##### Server

클라이언트의 서비스 요청을 받아서 서비스를 처리한 서버의 이름과 버전 정보를 나타낸다.

## 참고자료

- 오정임, 처음 해보는 Servlet & JSP 웹 프로그래밍(부천: 루비페이퍼, 2023), 608.